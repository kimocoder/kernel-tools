#!/bin/sh
# -*- coding: utf-8; mode: sh; tab-width: 3 -*-
#-------------------------------------------------------------------------------
# kernel-tools
# Copyright 2012-2013 Raffaello D. Di Napoli
#-------------------------------------------------------------------------------
# This file is part of kernel-tools.
#
# kernel-tools is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# kernel-tools is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# kernel-tools. If not, see <http://www.gnu.org/licenses/>.
# ------------------------------------------------------------------------------


# Retrieve Portage environment.
getportageenv() {
	p_arch=${1}
	p_makeopts="${2}"
	p_root="${3}"
	p_tmpdir="${4}"
	p_distcc=false
	local feature
	for feature in ${5}; do
		[ ${feature} = distcc ] && p_distcc=true
	done
}
eval getportageenv $(
	portageq envvar ARCH MAKEOPTS ROOT PORTAGE_TMPDIR FEATURES |
	sed -e 's/^.*$/"&"/'
)

# Source Gentoo initscript helpers.
. "${p_root}etc/init.d/functions.sh"

# Set option defaults.
kg_arch="${p_arch}"
kg_distcc=${p_distcc}
unset kg_initramfs
kg_initramfs_debug=false
kg_install=true
kg_makeopts="${p_makeopts}"
kg_pkg=
kg_rebuildmods=true
kg_root="${p_root}"
kg_src="${PWD}"
unset KG_VERBOSE

# Scan the command line.
makeabs() {
	local s
	eval s=\"\${1}\"
	[ "${s#/}" = "${s}" ] && eval ${1}=\"\${PWD}\${s}\"
}
for arg; do
	# Discard this argument.
	shift
	case "${arg}" in
	(-a|--arch=?*)
		kg_arch="${arg#*=}"
		;;
	(-i|--initramfs=?*)
		kg_initramfs="${arg#*=}"
		;;
	(--initramfs-debug)
		kg_initramfs_debug=true
		;;
	(--no-initramfs)
		kg_initramfs=
		;;
	(--no-install)
		kg_install=false
		;;
	(--no-rebuildmods)
		kg_rebuildmods=false
		;;
	(-p|--package=?*)
		kg_pkg="${arg#*=}"
		makeabs kg_pkg
		;;
	(-r|--root=?*)
		kg_root="${arg#*=}"
		makeabs kg_root
		kg_root="${kg_root%/}/"
		;;
	(-s|--source=?*)
		kg_src="${arg#*=}"
		if [ ! -d "${kg_src}" ]; then
			eerror 'Invalid kernel source directory.'
			exit 1
		fi
		makeabs kg_src
		;;
	(-v|--verbose)
		export KG_VERBOSE=1
		;;
	(--)
		break
		;;
	(*)	cat <<-EOF
		Usage: ${0##*/} [options]
		Possible options:
		-a, --arch=ARCH		Build a kernel for the specified ARCHitecture. Defaults
		 			to Portage's ARCH variable.
		-i, --initramfs=DIR	Use DIR as an initramfs source directory. Defaults to
		 			\`\${ROOT}/usr/src/initramfs'.
		    --initramfs-debug	Dumps the contents of the generated initramfs before
		 			packaging it.
		    --help		Show this informative message and quit.
		    --no-initramfs	Ignore the initramfs directory, even if existent.
		    --no-install	Don't install the compiled kernel; also ignores --root
		 			and --no-rebuildmods.
		    --no-rebuildmods	Don't rebuild packages providing external modules;
		 			delete the module files instead.
		-p, --package=FILE	Copy the kernel to a compressed tar archive named FILE.
		-r, --root=DIR		Use DIR as root directory. Defaults to Portage's
		 			\${ROOT}.
		-s, --source=DIR	Select DIR as the kernel source directory. Defaults to
		 			the current directory or \`\${ROOT}/usr/src/linux'.
		-v, --verbose		Enable extended output (mainly from the package manager)
		EOF
		[ "${arg}" = '--help' ]
		exit
		;;
	esac
done
kg_src="${kg_src%/}/"

# Check for conflicting/improper arguments.
if ! ${kg_install} && [ -z "${kg_pkg}" ]; then
	eerror 'Option --no-install cannot be used without --package.'
	eerror 'You must choose to install the new kernel, package it, or both.'
	exit 1
fi

# Determine the ARCH and the generated kernel file name.
kg_src_img=
case ${kg_arch} in
(x86)
	ARCH=i386
	kg_src_img=arch/x86/boot/bzImage
	;;
(amd64)
	ARCH=x86_64
	kg_src_img=arch/x86/boot/bzImage
	;;
(ppc)
	ARCH=powerpc
	;;
(*)
	eerror "Unsupported ARCH: ${kg_arch}"
	exit 1
	;;
esac
export ARCH
export PORTAGE_ARCH=${kg_arch}

kmake() {
	make -C "${kg_src}" ${kg_makeopts} "${@}"
}

# Ensure we have a valid kernel, and get its version.
getkv() {
	kg_kv=$(kmake -s kernelrelease 2>/dev/null | grep -v '^#')
	[ ${?} -eq 0 -a -n "${kg_kv}" ]
}

if ! getkv; then
	# No kernel was specified: find one, first checking if the standard symlink
	# is in place.
	kg_src="${p_root}usr/src/linux"
	if [ -d "${kg_src}" ]; then
		if ! getkv; then
			eerror 'Unable to determine the version of the selected kernel source.'
			exit 1
		fi
	else
		eerror 'No suitable kernel source directory was found; please consider using the'
		eerror "--source option, or invoke ${0##*/} from within a kernel source directory."
		eerror
		eerror 'You can enable the [1;34msymlink[0m USE flag to keep an up-to-date symlink to your'
		eerror 'current kernel source directory in [1;36m/usr/src/linux[0m.'
		eerror
		eerror 'Unable to locate a kernel source directory.'
		exit 1
	fi
fi
kg_src="$(readlink -f "${kg_src}")"
kg_src="${kg_src%/}/"
kg_src_cfg="${kg_src}.config"
kg_src_sysmap="${kg_src}System.map"

# Check that the kernel has already been configured. One of these lines must be
# near the top of .config:
#   Linux/i386 2.6.37 Kernel Configuration
#   Linux kernel version: 2.6.34
if awk -v sKV="${kg_kv}" '
	$0 ~ /^# Linux\/[^ ]* [^ ]* Kernel Configuration/ && $3 == sKV {
		exit 1
	}
	$0 ~ /^# Linux kernel version: / && $5 == sKV {
		exit 1
	}
	NR == 5 {
		# Give up.
		exit
	}
' <"${kg_src_cfg}" 2>/dev/null; then
	eerror 'This kernel needs to be configured first.'
	eerror 'Try:'
	eerror "	make -C \"${kg_src}\" menuconfig"
	exit 1
fi

# Get the kernel image compression method from the config file.
kg_kernel_compr=$(awk '
	/^CONFIG_KERNEL_(GZIP|BZIP2|LZMA|LZO)=y$/ {
		print tolower(substr($0, 1 + 14, length() - 14 - 2))
	}
' <"${kg_src_cfg}")

# If default, or if not compressed, just use the plain image.
[ -z "${kg_src_img}" -o -z "${kg_kernel_compr}" ] && kg_src_img=vmlinux
kg_src_img="${kg_src}${kg_src_img}"

# Check for initramfs/initrd support with the config file.
if grep -q '^CONFIG_BLK_DEV_INITRD=y$' <"${kg_src_cfg}"; then
	if [ "${kg_initramfs-unset}" = unset ]; then
		if [ -d "${p_root}usr/src/initramfs" ]; then
			kg_initramfs="${p_root}usr/src/initramfs"
		else
			ewarn
			ewarn 'The selected kernel was configured to support initramfs/initrd,'
			ewarn 'but no suitable initramfs source directory was specified or found.'
			ewarn 'No initramfs will be created.'
			kg_initramfs=
		fi
	fi
else
	if [ -n "${kg_initramfs}" ]; then
		eerror
		eerror 'The selected kernel was not configured to support initramfs/initrd.'
		exit 1
	fi
fi
if [ -n "${kg_initramfs}" ]; then
	# TODO: check that these CONFIG_ match:
	#   +DEVTMPFS

	# Try to pick, for the initramfs, the same compression as the kernel.
	# Otherwise, pick any selected compression method, or remember not to
	# compress at all.
	kg_initramfs_compr=$(awk -v sKCompr=${kg_kernel_compr} '
		/^CONFIG_RD_(GZIP|BZIP2|LZMA|LZO)=y$/ {
			sICompr = sICompr " " tolower(substr($0, 1 + 10, length() - 10 - 2))
		}
		END {
			if (sKCompr && index(sICompr, sKCompr))
				# Same as the kernel image.
				sICompr = sKCompr
			else {
				# Pick the first supported, or none.
				sub(/^ /, "", sICompr)
				sub(/ .*$/, "", sICompr)
			}
			sIExt = sICompr
			# The lzo executable is in fact lzop.
			if (sICompr == "lzo")
				sICompr = "lzop"
			# bzip2 => bz2, gzip => gz.
			sub(/ip/, "", sIExt)
			print sICompr " " sIExt
		}
	' <"${kg_src_cfg}")
	kg_initramfs_ext=${kg_initramfs_compr#* }
	kg_initramfs_compr=${kg_initramfs_compr% *}
	kg_src_initramfs="${kg_initramfs:+${p_tmpdir}/initramfs.cpio.${kg_initramfs_ext}}"
fi

# Determine if cross-compiling.
CROSS_COMPILE=$(
	sed -ne 's/^CONFIG_CROSS_COMPILE="\([^"]*\)"$/\1/p' <"${kg_src_cfg}"
)
export CROSS_COMPILE


einfo 'Preparing to build:'
eindent
einfo "[1;32mlinux-${kg_kv}[0m (${ARCH})"
einfo "from [1;37m${kg_src}[0m"

if [ -n "${kg_initramfs}" ]; then
	# Check that a valid initramfs directory was specified.
	if ! kg_initramfs=$(readlink -e "${kg_initramfs}"); then
		eerror 'Invalid initramfs directory'
		exit 1
	fi
	einfo "with initramfs from [1;37m${kg_initramfs}[0m"
fi
if [ -n "${CROSS_COMPILE}" ]; then
	einfo "cross-compiled with [1;37m${CROSS_COMPILE%-}[0m toolchain"
fi
eoutdent
einfo

# Use distcc, if enabled.
# TODO: also add HOSTCC.
if ${kg_distcc}; then
	einfo 'Distributed C compiler (distcc) enabled'
	kg_makeopts="${kg_makeopts} CC=distcc"
	export DISTCC_DIR="${p_tmpdir}/portage/.distcc"
	mkdir -p "${DISTCC_DIR}"
fi


# Calculates paths for the files' final locations.
getdstpaths() {
	kg_dst_img="${kg_root}boot/linux-${kg_kv}"
	kg_dst_initramfs="${kg_root}boot/initramfs-${kg_kv}.cpio.${kg_initramfs_ext}"
	kg_dst_cfg="${kg_root}boot/config-${kg_kv}"
	kg_dst_sysmap="${kg_root}boot/System.map-${kg_kv}"
	kg_dst_mods="${kg_root}lib/modules/${kg_kv}"
}

# Only invoke make if .config was changed since last compilation.
if [ ! -e "${kg_src_img}" -o "${kg_src_cfg}" -nt "${kg_src_img}" ]; then
	ebegin "Building linux-${kg_kv}"
	kmake "${@}"
	retval=${?}
	einfo "Finished building linux-${kg_kv}"
	eend ${retval} || exit

	# kmake won't touch the kernel image if .config doesn't require so, which
	# means that the above test would always cause this if branch to be entered.
	# A way to avoid this is to touch the kernel image now.
	touch -m "${kg_src_img}"

	if ${kg_rebuildmods}; then
		ebegin 'Rebuilding kernel module packages'
		kg_modpkgs=$(kernel-lsext -m -p)
		if [ -n "${kg_modpkgs}" ]; then
			env KERNEL_DIR="${kg_src}" \
				"${CROSS_COMPILE}emerge" -q1 --usepkg=n --quiet-build \
				${kg_modpkgs} \
				>/dev/null
			eend ${?} || exit
		else
			eend 0
		fi
	fi
fi

if [ -n "${kg_initramfs}" ]; then
	kg_work="${p_tmpdir}/initramfs-${kg_kv}/"
	if [ -d "${kg_work%/}" ]; then
		rm -rf "${kg_work}"*
	else
		mkdir "${kg_work%/}"
	fi
	cd "${kg_work}"

	einfo 'Generating initramfs'
	eindent

	ebegin 'Adding kernel modules'
	kmake INSTALL_MOD_PATH="${kg_work}" modules_install >/dev/null
	eend ${?} || exit
	# TODO: more proper way of excluding modules from the initramfs.
	rm -rf "${kg_work}"lib*/modules/*/kernel/sound

	ebegin 'Adding out-of-tree firmware'
	# Create the folder beforehand; it not needed, we'll delete it later.
	kg_fwdir="${kg_work}lib/firmware"
	mkdir -p "${kg_fwdir}"
	for kg_extfw in $(env ROOT="${kg_root}" kernel-lsext -w -f); do
		# If the firmware is in a subfolder, create it.
		kg_exfwdir=${kg_extfw%/*}
		if [ ${kg_exfwdir} != ${kg_extfw} ]; then
			mkdir -p "${kg_fwdir}/${kg_exfwdir}"
		fi
		# Copy the firmware file.
		cp -a "${kg_root}lib/firmware/${kg_extfw}" "${kg_fwdir}/${kg_extfw}" ||
			eend ${?} || exit
	done
	eend ${?} || exit
	# If /lib/firmware is still empty, delete it.
	rmdir "${kg_fwdir}" 2>/dev/null

	if [ -f "${kg_initramfs}/build" -a -x "${kg_initramfs}/build" ]; then
		# The initramfs has a build script; invoke it.
		einfo 'Invoking initramfs custom build script'
		eindent
		# ARCH, PORTAGE_ARCH and CROSS_COMPILE are already exported.
		env ROOT="${kg_root}" KERNEL_DIR="${kg_src}" "${kg_initramfs}/build" ||
			exit
		eoutdent
	else
		# No build script; just copy every file.
		ebegin 'Adding source files'
		cp -a "${kg_initramfs}/"* "${kg_work}"
		eend ${?} || exit
	fi

	if ${kg_initramfs_debug}; then
		initramfs_ls="${p_tmpdir}/initramfs-${kg_kv}.ls"
		ebegin "Dumping contents of generated initramfs to ${initramfs_ls}"
		ls -lR --color=always >"${initramfs_ls}"
		eend ${?} || exit
		unset initramfs_ls
	fi

	ebegin 'Creating archive'
	find . -mindepth 1 -printf '%P\0' |
	cpio --create --format newc --null 2>/dev/null |
	${kg_initramfs_compr:-cat} ${kg_initramfs_compr:+-9} >"${kg_src_initramfs}"
	eend ${?} && [ -s "${kg_src_initramfs}" ] || exit

	ebegin 'Cleaning up initramfs'
	cd - >/dev/null
	rm -rf "${kg_work}"
	eend ${?} || exit

	eoutdent
fi

if ${kg_install}; then
	getdstpaths

	dirsize() {
		if [ -d "${1}" ]; then
			find "${1}" -name '*.ko' -printf '%s\n' |
			awk '{ cb += $0 } END { print cb }'
		else
			echo 0
		fi
	}
	filesize() {
		if [ -f "${1}" ]; then
			stat -c'%s' "${1}"
		else
			echo 0
		fi
	}
	einfo_sizediff() {
		if [ ${2} -eq ${3} ]; then
			einfo "${1} size unchanged at $(( ( ${3} + 1023 ) / 1024 )) KiB"
		elif [ ${2} -eq 0 ]; then
			einfo "${1} size is $(( ( ${3} + 1023 ) / 1024 )) KiB"
		else
			local plussign=
			[ ${3} -gt ${2} ] && plussign='+'
			einfo "${1} size changed from $((
				( ${2} + 1023 ) / 1024
			)) KiB to $((
				( ${3} + 1023 ) / 1024
			)) KiB (${plussign}$((
				( ${3} - ${2} ) * 100 / ${2}
			))%)"
		fi
	}

	if [ "${kg_root}" = / ]; then
		einfo 'Installing kernel'
	else
		einfo "Installing kernel to ${kg_root}"
	fi
	eindent

	# Ensure /boot is mounted.
	[ -d "${kg_root}boot" ] || mkdir "${kg_root}boot"
	kg_boot_unmount=false
	if [ ! -e "${kg_root}boot/boot" ]; then
		# Maybe /boot needs to be mounted. Can't just run mount /boot, since
		# ${kg_root} is not necessarily '/'.
		kg_boot_mount=$(awk '
			!/^#/ && $2 == "/boot" {
				print $1 " -t " $3 " -o " $4
			}
		' <"${kg_root}etc/fstab")
		if [ -n "${kg_boot_mount}" ]; then
			ebegin "Mounting ${kg_boot_mount%% *} to ${kg_root}boot"
			mount ${kg_boot_mount} "${kg_root}boot"
			eend ${?} || exit
			kg_boot_unmount=true
		fi
	fi

	# Remove any initramfs-${kg_kv}.cpio.*, not just the one we're going to
	# replace; this ensures we don't leave around a leftover initramfs just
	# because it uses a different compression algorithm.
	if [ \
		-e "${kg_dst_img}" -o \
		-e "${kg_dst_mods}" -o \
		-e "${kg_dst_initramfs%.*}".* \
	]; then
		ebegin 'Removing old files'
		kg_kernel_size=$(filesize "${kg_dst_img}")
		kg_mods_size=$(dirsize "${kg_dst_mods}")
		kg_initramfs_size=$(filesize "${kg_dst_initramfs}")
		rm -f "${kg_dst_img}" "${kg_dst_initramfs%.*}".* \
			"${kg_dst_cfg}" "${kg_dst_sysmap}"
		# Remove every in-tree kernel module, leaving only the out-of-tree ones.
		find "${kg_dst_mods}" $(
			env ROOT="${kg_root}" kernel-lsext -m -f |
			sed -e 's|^|! -path \*/|'
		) \( ! -type d -o -empty \) -delete
		eend ${?}
	else
		kg_kernel_size=0
		kg_mods_size=0
		kg_initramfs_size=0
	fi

	ebegin 'Installing kernel image'
	cp -a "${kg_src_img}" "${kg_dst_img}" &&
	cp -a "${kg_src_cfg}" "${kg_dst_cfg}" &&
	cp -a "${kg_src_sysmap}" "${kg_dst_sysmap}"
	eend ${?} || exit
	if [ ${kg_kernel_size} -gt 0 ]; then
		eindent
		einfo_sizediff Kernel ${kg_kernel_size} $(filesize "${kg_dst_img}")
		eoutdent
	fi

	einfon 'Installing modules ...'
	kmake INSTALL_MOD_PATH="${kg_root}" modules_install |
	awk '
		$1 == "INSTALL" {
			cMods += 1
		}
		END {
			print " (" cMods ")"
		}
	'
	eend 0
	if [ ${kg_mods_size} -gt 0 ]; then
		eindent
		einfo_sizediff Modules ${kg_mods_size} $(dirsize "${kg_dst_mods}")
		eoutdent
	fi

	if [ -n "${kg_initramfs}" ]; then
		ebegin 'Installing initramfs'
		cp -a "${kg_src_initramfs}" "${kg_dst_initramfs}"
		eend ${?} || exit
		if [ ${kg_initramfs_size} -gt 0 ]; then
			eindent
			einfo_sizediff initramfs \
				${kg_initramfs_size} $(filesize "${kg_dst_initramfs}")
			eoutdent
		fi
	fi

	if ${kg_boot_unmount}; then
		ebegin "Unmounting ${kg_root}boot"
		umount "${kg_root}boot"
		eend ${?} || exit
	fi

	eoutdent
fi

if [ -n "${kg_pkg}" ]; then
	kg_root="${p_tmpdir}/pkg-${kg_kv}/"
	mkdir -p "${kg_root}boot" "${kg_root}lib/modules"

	# Recalculate the destinations, to collect everything into the temporary
	# directory.
	getdstpaths

	einfo 'Preparing kernel package'
	eindent

	ebegin 'Adding kernel image'
	cp -a "${kg_src_img}" "${kg_dst_img}" &&
	cp -a "${kg_src_cfg}" "${kg_dst_cfg}" &&
	cp -a "${kg_src_sysmap}" "${kg_dst_sysmap}"
	eend ${?} || exit

	ebegin 'Adding modules'
	kmake INSTALL_MOD_PATH="${kg_root}" modules_install
	eend 0

	if [ -n "${kg_initramfs}" ]; then
		ebegin 'Adding initramfs'
		cp -a "${kg_src_initramfs}" "${kg_dst_initramfs}"
		eend ${?} || exit
	fi

	ebegin 'Creating archive'
	# If ${PWD} was modified by --source, restore it now.
	tar -C "${kg_root}" -cjf "${kg_pkg}" boot lib
	eend ${?} || exit

	einfo 'Cleaning up kernel package'
	rm -rf "${kg_root}"
	eend ${?}

	eoutdent
fi

if [ -n "${kg_initramfs}" ]; then
	einfo 'Cleaning up temporary files'
	rm -f "${kg_src_initramfs}"
	eend ${?}
fi

