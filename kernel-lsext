#!/bin/sh
# -*- coding: utf-8; mode: sh; tab-width: 3 -*-
#-------------------------------------------------------------------------------
# kernel-tools
# Copyright 2012 Raffaello D. Di Napoli
#-------------------------------------------------------------------------------
# This file is part of kernel-tools.
#
# kernel-tools is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# kernel-tools is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# kernel-tools. If not, see <http://www.gnu.org/licenses/>.
#-------------------------------------------------------------------------------
#
# Lists external firmware and/or modules for Linux along with the packages that
# installed them.


files=0
firmware=0
modules=0
packages=0

# Scan the command line.
for arg; do
	case "${arg}" in
	(-f|--files)
		files=1
		;;
	(-m|--modules)
		modules=1
		;;
	(-p|--packages)
		packages=1
		;;
	(-w|--firmware)
		firmware=1
		;;
	(*)
		cat <<-EOF
			Usage: ${0##*/} [options]

			Options:
			-f, --files	Show the matching files; default.
			-w, --firmware	List external firmware installed by non-kernel packages.
			    --help	Show this informative message.
			-m, --modules	List modules installed by non-kernel packages.
			-p, --packages	Change -m and/or -w to only show the containing packages,
			 		overriding -f if not specified. If combined with -f, show
			 		packages on the same line as the files they contain.
		EOF
		[ "${arg}" = --help ]
		exit
		;;
	esac
done

[ ${files} -eq 0 -a ${packages} -eq 0 ] && files=1


vdb_path=$(portageq vdb_path)

find "${vdb_path}" -mindepth 3 -maxdepth 3 -type f -name CONTENTS -exec \
awk -v cchVdbPath=$((${#vdb_path} + 2)) \
	 -v sRoot="${ROOT}" \
	 -v bFiles=${files} \
	 -v bFw=${firmware} \
	 -v bMods=${modules} \
	 -v bPkgs=${packages} '
	BEGIN {
		FIRMWARE_TYPE = 0
		MODULE_TYPE = 1
		cchRoot = (sRoot ? length(sRoot) + 1 : 2)
		sFwPath = "lib/firmware/"
		cchFwPath = length(sFwPath)
		cchModPath = length("lib/modules/")
	}
	$1 == "obj" {
		if ($2 ~ /\.ko$/) {
			if (!bMods)
				next
			iFileType = MODULE_TYPE
		} else if (substr($2, cchRoot, cchFwPath) == sFwPath) {
			if (!bFw)
				next
			iFileType = FIRMWARE_TYPE
		} else
			next
		if (bPkgs) {
			# Get the directory that contains this CONTENTS file, i.e. its package.
			sDir = ARGV[ARGIND]
			sDir = substr(sDir, 1, length(sDir) - 9)
			# Cache the SLOTs in an array.
			if (!(sDir in arrPkgSlots)) {
				sSlot = sDir "/SLOT"
				getline arrPkgSlots[sDir] < sSlot
				close(sSlot)
			}
			sSlot = arrPkgSlots[sDir]
			# Get the package name and version by stripping the VDB path.
			sPkg = substr(sDir, cchVdbPath)
			# Replace the package version with its slot.
			sub(/-[0-9].*$/, ":" sSlot, sPkg)
		}
		if (bFiles) {
			# If displaying file names, we have to get the relative path of $2.
			# Remove "${ROOT}/".
			sFile = substr($2, cchRoot)
			if (iFileType == FIRMWARE_TYPE)
				# Remove "lib/firmware/", and add a leading space.
				sFile = " " substr(sFile, cchFwPath + 1)
			else if (iFileType == MODULE_TYPE) {
				# Remove "lib/modules/".
				sFile = substr(sFile, cchModPath + 1)
				# Remove "linux-*/" and add a leading space.
				sub(/^[^\/]+\//, " ", sFile)
			}

			if (bPkgs)
				# Store packages and files.
				arrFilesByPkg[sPkg] = arrFilesByPkg[sPkg] sFile
			else if (bFiles)
				# Store files only.
				sFiles = sFiles sFile
		} else if (bPkgs)
			# Store packages only.
			arrFilesByPkg[sPkg] = 1
	}
	END {
		if (bPkgs)
			for (sPkg in arrFilesByPkg)
				if (bFiles)
					# Print packages and files.
					print sPkg arrFilesByPkg[sPkg]
				else
					# Print packages only.
					print sPkg
		else if (bFiles && length(sFiles)) {
			# Print files only.
			# Delete the leading space.
			sFiles = substr(sFiles, 2)
			# One file per line.
			gsub(/ /, "\n", sFiles)
			print sFiles
		}
	}
' {} +

